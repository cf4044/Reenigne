using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;


namespace Reenigne
{
#pragma warning disable IDE1006

	namespace mogul
	{
		
	}


	public partial class mainForm : Form
	{
		// Main form initialisation
		public mainForm()
		{
			InitializeComponent();      // This is generated by the forms designer - do not alter or remove. here 'Componennt' is to do with Windows, not the electronic components this project is about.  

			// Add event handlers for the board picture box
			boardPictureBox.MouseDown  += boardPictureBox_MouseDown;
			boardPictureBox.MouseMove  += boardPictureBox_Move;
			boardPictureBox.MouseClick += boardPictureBox_Click;
			boardPictureBox.MouseEnter += boardPictureBox_MouseEnter;
			boardPictureBox.MouseLeave += boardPictureBox_MouseLeave;
			boardPictureBox.MouseWheel += boardPictureBox_MouseWheel;

			// Add event handlers for the board picture box
			circuitPictureBox.MouseDown  += circuitPictureBox_MouseDown;
			circuitPictureBox.MouseMove  += circuitPictureBox_Move;
			circuitPictureBox.MouseClick += circuitPictureBox_Click;
			circuitPictureBox.MouseEnter += circuitPictureBox_MouseEnter;
			circuitPictureBox.MouseLeave += circuitPictureBox_MouseLeave;
			circuitPictureBox.MouseWheel += circuitPictureBox_MouseWheel;

			//ContextMenu boardContextMenu = new ContextMenu();
			//boardContextMenu.MenuItems.Add("Item 1", new EventHandler(boardItem1_Click));
			//boardContextMenu.MenuItems.Add("Item 2", new EventHandler(boardItem2_Click));
			//boardPictureBox.ContextMenu = boardContextMenu;

			quit = true;	// This means that any closing of the main window will quit the program unless explicitly cleared, such as for example when closing the form to re-open the project	rather than to exit
			openFile( "D:\\Dropbox\\o\\Reenigne\\TestProject\\KBTest.txt");   // KLUDGE - to load the project file immediately on startup
			mainFormReformat();			
		}

		// Actions relating the the main form - opening, closing, resizing etc
		private void mainForm_Load( object sender, EventArgs e )
		{

		}
		private void mainForm_Shown( object sender, EventArgs e )
		{
			Top = 559;
			Left = 175;
			Width = 2359;
			Height = 1223;
			redrawBoards();
			Refresh();
		}
		private void mainForm_Activated( object sender, EventArgs e )
		{
			//redrawBoards();
		}
		private void mainForm_ResizeEnd( object sender, EventArgs e )
		{
			Console.WriteLine( "Main window resized to {0},{1},{2},{3} (top/left/width/height)", Top, Left, Width, Height );
		}
		private void mainForm_Resize( object sender, EventArgs e )
		{
			mainFormReformat();
			//if (WindowState == FormWindowState.Maximized && !wasMaximized)
			//{ mainFormReformat(); wasMaximized = true;  return; };

			//if (WindowState != FormWindowState.Maximized &&  wasMaximized)
			//{ mainFormReformat(); wasMaximized = false; return; };
		}
		protected override void OnFormClosing( FormClosingEventArgs e )
		{
			
		}

		// Actions related to the board picture box - scrolling, zooming etc
		private void boardPictureBox_MouseDown( object sender, MouseEventArgs e )
		{
			if( e.Button == MouseButtons.Middle )   // pressed the moushweel button to start dragging the image
			{
				mouseWheelPressed = true;
				mouseWheelStartX = e.X;
				mouseWheelStartY = e.Y;
				Console.WriteLine( "Button pressed {0} : startX {1} : startY {2}", e.Button, mouseWheelStartX, mouseWheelStartY );
			}
			if( e.Button == MouseButtons.Left )   // pressed the left button 
			{
				// drawing on the board image
				switch( boardMouseMode )
				{
					case boardMouseModes.selectItem:
						selectItemClick( sender, e );
						break;
					case boardMouseModes.drawTrace:
						drawTraceClick( sender, e );
						break;
					case boardMouseModes.insertVia:
						insertViaClick( sender, e );
						break;
					case boardMouseModes.addComponent:
						addComponentClick( sender, e );
						break;
					default:
						break;
				}

			}
		}
		private void boardPictureBox_Move( object sender, MouseEventArgs e )
		{
			// Show the mouse co-ordinates
			// boardImages[0].screenCoordFromBoardCoord(new PointF { X=e.X, Y=e.Y });
			PointF tmp = boardImages[0].boardCoordFromScreenCoord( new PointF { X = e.X, Y = e.Y } );
			textBoxCoordinates.Text = tmp.X.ToString() + " : " + tmp.Y.ToString();

			// Panning with the mousewheel button
			if( mouseWheelPressed )   // this can be disabled to prevent continuous refresh when dragging
			{
				// -----  Draw the 'permanent' graphics ----------------------------
				// ----- these are drawn onto the 'boardGraphics' object and will appear on the screen only after a 'Refresh'
				int x = e.X;
				int y = e.Y;
				for( int i = 0; i < boardImages.Count; i++ )
					boardImages[i].move( x - mouseWheelStartX, y - mouseWheelStartY );
				mouseWheelStartX = e.X;
				mouseWheelStartY = e.Y;
				Console.WriteLine( "Dragging" );
				redrawBoards( quick: true );
			}
			//Refresh();   // This makes the stuff drawn above to 'boardGraphics' to actually appear and overwriting anything that had been drawn to boardPictureBox.Image
			// -----  draw the 'transient' graphics, such as when rubberbanding while adding traces, moving components and so on.
			// -----  these will only be drawn as an opverlay on the screen rather than embedded in the 'boardGraphics' object
			// Drawing traces on the board image
			if( boardMouseMode == boardMouseModes.drawTrace )
			{
				Refresh();
				drawTraceMove( sender, e );
			}
			if( boardMouseMode == boardMouseModes.addComponent  )
			{
				Refresh();
				drawComponentMove( e.X, e.Y  );
			}
			
		}
		private void boardPictureBox_Click( object sender, MouseEventArgs e )
		{   // note that this activates when a mouse button is released, not when it is pressed
			if( e.Button == MouseButtons.Middle )
			{
				int x = e.X;
				int y = e.Y;
				mouseWheelPressed = false;
				for( int i = 0; i < boardImages.Count; i++ )
					boardImages[i].move( x - mouseWheelStartX, y - mouseWheelStartY );
				redrawBoards();
			}
			//Console.WriteLine("Button Released {0}", e.Button);
		}
		private void boardPictureBox_MouseEnter( object sender, EventArgs e )
		{
			boardPictureBoxActive = true;
		}
		private void boardPictureBox_MouseLeave( object sender, EventArgs e )
		{
			boardPictureBoxActive = false;
			mouseWheelPressed = false;
		}
		private void boardPictureBox_MouseWheel( object sender, MouseEventArgs e )
		{   // zoming in/out the board image
			int s = scrollBarBoardZoom.Value + e.Delta / 20;
			if( s < scrollBarBoardZoom.Minimum ) s = scrollBarBoardZoom.Minimum;
			if( s > scrollBarBoardZoom.Maximum ) s = scrollBarBoardZoom.Maximum;
			scrollBarBoardZoom.Value = s;
			for( int i = 0; i < boardImages.Count; i++ )
				boardImages[i].setScaleIndex( s, e.X, e.Y, boardPictureBox.Width, boardPictureBox.Height );
			//this.SuspendLayout();
			redrawBoards();
			Refresh();
			//this.ResumeLayout(false);
			Console.WriteLine( "Scroll {0} - button {1}", e.Delta, e.Button );
		}

		// Actions related to the schematic diagram picture box - scrolling, zooming etc
		private void circuitPictureBox_MouseDown( object sender, MouseEventArgs e )
		{
			if( e.Button == MouseButtons.Middle )   // pressed the moushweel button to start dragging the image
			{
				mouseWheelPressed = true;
				mouseWheelStartX = e.X;
				mouseWheelStartY = e.Y;
				Console.WriteLine( "Button pressed {0} : startX {1} : startY {2}", e.Button, mouseWheelStartX, mouseWheelStartY );
			}
			if( e.Button == MouseButtons.Left )   // pressed the left button 
			{
				mouseLeftPressed = true;
				componentSelctorIndex = -1;
				sectionSelectorIndex = -1;

				PointF mousePoint = schematic.schemCoordFromScreenCoordF( new PointF( e.X, e.Y ) );
				foreach( component comp in traceHandler.componentss )
				{
					foreach( component.section sec in comp.sections )
					{
						if ( sec.absBoundBox.Contains( mousePoint ))
						{	// set up to start dragging the component
							mouseLeftStartX = mousePoint.X;
							mouseLeftStartY = mousePoint.Y;
							componentSelctorIndex = traceHandler.componentss.IndexOf( comp );
							sectionSelectorIndex  = traceHandler.componentss[componentSelctorIndex].sections.IndexOf( sec );
							Console.WriteLine( "Selected component {0}, section {1}", componentSelctorIndex, sectionSelectorIndex );
						}
					}
				}
				if( componentSelctorIndex < 0 || sectionSelectorIndex < 0 ) Console.WriteLine( "No component selected" );
			}
		}
		private void circuitPictureBox_Move( object sender, MouseEventArgs e )
		{
			// Show the mouse co-ordinates
			PointF tmp = schematic.schemCoordFromScreenCoord( new PointF { X = e.X, Y = e.Y } );
			textBoxCoordinates.Text = tmp.X.ToString() + " : " + tmp.Y.ToString();

			// Panning with the mousewheel button
			if( mouseWheelPressed )   // this can be disabled to prevent continuous refresh when dragging
			{
				// -----  Draw the 'permanent' graphics ----------------------------
				// ----- these are drawn onto the 'circuitGraphics' object and will appear on the screen only after a 'Refresh'
				int x = e.X;
				int y = e.Y;
				Console.WriteLine( "Dragging from {0},{1} to {2},{3}", x, y, mouseWheelStartX, mouseWheelStartY );
				schematic.move( x - mouseWheelStartX, y - mouseWheelStartY );
				mouseWheelStartX = e.X;
				mouseWheelStartY = e.Y;
				Console.WriteLine( "Dragging" );
				schematic.drawSchematic( schemGraphics, traceHandler.componentss /* quick: true*/ );
				Refresh();
			}
			// Dragging with the left mouse buton
			if ( mouseLeftPressed )
			{
				if( componentSelctorIndex >= 0 && sectionSelectorIndex >= 0 )
				{
					PointF mousePoint = schematic.schemCoordFromScreenCoordF( new PointF( e.X, e.Y ) );
					traceHandler.componentss[componentSelctorIndex].sections[sectionSelectorIndex].position.X += mousePoint.X - mouseLeftStartX;
					traceHandler.componentss[componentSelctorIndex].sections[sectionSelectorIndex].position.Y += mousePoint.Y - mouseLeftStartY;
					mouseLeftStartX = mousePoint.X;
					mouseLeftStartY = mousePoint.Y;
					schematic.drawSchematic( schemGraphics, traceHandler.componentss /* quick: true*/ );
					Refresh();
				}
			}
			//Refresh();   // This makes the stuff drawn above to 'circuitGraphics' to actually appear and overwriting anything that had been drawn to circuitPictureBox.Image
			// -----  draw the 'transient' graphics, such as when rubberbanding while adding traces, moving components and so on.
			// -----  these will only be drawn as an opverlay on the screen rather than embedded in the 'circuitGraphics' object
			// Drawing traces on the circuit image
			//if( circuitMouseMode == circuitMouseModes.drawTrace )
			//{
			//	drawTraceMove( sender, e );
			//}
			//if( circuitMouseMode == circuitMouseModes.addComponent )
			//{
			//	drawComponentMove( e.X, e.Y );
			//}

		}
		private void circuitPictureBox_Click( object sender, MouseEventArgs e )
		{   // note that this activates when a mouse button is released, not when it is pressed
			if( e.Button == MouseButtons.Middle )
			{
				int x = e.X;
				int y = e.Y;
				mouseWheelPressed = false;
				schematic.drawSchematic( schemGraphics, traceHandler.componentss /* quick: false*/ );
			}
			if( e.Button == MouseButtons.Left )
			{
				mouseLeftPressed = false;
			}
		}
		private void circuitPictureBox_MouseEnter( object sender, EventArgs e )
		{
			circuitPictureBoxActive = true;
		}
		private void circuitPictureBox_MouseLeave( object sender, EventArgs e )
		{
			circuitPictureBoxActive = false;
			mouseWheelPressed = false;
			mouseLeftPressed  = false;
		}
		private void circuitPictureBox_MouseWheel( object sender, MouseEventArgs e )
		{   // zoming in/out the circuit image
			int s = circuitZoomIndex + e.Delta / 20;
			if( s < -100 ) s = -100;
			if( s > 200 ) s = 200;
			circuitZoomIndex = s;
			schematic.setScaleIndex( s, e.X, e.Y, circuitPictureBox.Width, circuitPictureBox.Height );
			//this.SuspendLayout();
			schematic.drawSchematic( schemGraphics, traceHandler.componentss /* quick: true*/ );
			Refresh();
			//this.ResumeLayout(false);
			Console.WriteLine( "Scroll {0} - button {1}", e.Delta, e.Button );
		}


		// Top panel controls
		private void buttonSave_Click( object sender, EventArgs e )
		{
			StreamWriter writer = new StreamWriter( "D:\\Dropbox\\o\\Reenigne\\TestProject\\KBTest.txt" );
			traceHandler.writeSegments( writer );
			traceHandler.writeVias( writer );
			boardImage.writeConfig( writer, boardImages );
			component.writeComponents( writer, traceHandler.componentss );  
			writer.Close();
		}
		private void buttonOpen_Click( object sender, EventArgs e )
		{   // re/opens the project by simply exiting and restarting since file is loaded on starting the program
			quit = false;
			Close();
			
			//StreamReader reader = new StreamReader( "D:\\Dropbox\\o\\Reenigne\\TestProject\\KBTest.txt" );
			//traceHandler.readSegments( reader );
			//traceHandler.readVias( reader );
			//boardImage.readConfig( reader, boardImages, this );
			//component.readComponents( reader, traceHandler.componentss );
			//reader.Close();
			//traceHandler.findNetTopology();
			//redrawBoards();
		}
		private void buttonRefresh_Click( object sender, EventArgs e )
		{   // this is just a temporary thing for development - should not be needed in the finished product
			redrawBoards();
		}

		// Left panel controls
		private void radioButtonModeSelect_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModeSelect.Checked )
			{
				boardMouseMode = boardMouseModes.selectItem;
			}
		}
			private void contextMenuSelectionType_ItemClicked( object sender, ToolStripItemClickedEventArgs e )
			{
				if( e.ClickedItem.Equals( allToolStripMenuItem ) || e.ClickedItem.Equals( noneToolStripMenuItem ) )
				{
					pointToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					lineToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					traceToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					netToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					viaThruHoleToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					componentToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
				}
			}
		private void radioButtonModeDrawTrace_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModeDrawTrace.Checked )
			{
				boardMouseMode = boardMouseModes.drawTrace;
			}
			else
			{
				drawTraceAbort();
			}
		}
		private void radioButtonModeDropVia_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModeDropVia.Checked )
			{
				boardMouseMode = boardMouseModes.insertVia;
			}
		}
		private void radioButtonModeDropThroughHole_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModeDropThroughHole.Checked )
			{
				boardMouseMode = boardMouseModes.insertThroughHole;
			}
		}
		private void radioButtonModePlaceComponent_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModePlaceComponent.Checked )
			{
				boardMouseMode = boardMouseModes.addComponent;
				addComponentStart( );
			}
			else
			{
				addComponentAbort();
			}
		}
			private void contextMenuComponentType_ItemClicked( object sender, ToolStripItemClickedEventArgs e )
			{
				Console.WriteLine( "ComponentT type menu {0}",e.ClickedItem.ToString() );
				int i=traceHandler.componentss.Count()-1;
				if( i < 0 ) return;
				if 
				(
					menuItemHilite( e, new List<ToolStripItem> { compTypeSIL, compTypeDIL, compTypeCircular, compTypeSquare } )
					||
					menuItemHilite( e, new List<ToolStripItem> { outlineHeader, outlineRectangular, outlineCircular } )
				)
				traceHandler.componentss[i].reformatPins( e.ClickedItem.Name );

				if ( menuItemHilite( e, new List<ToolStripItem> { pinTypeSmd, pinTypeThruHole } ) )
				{
					if( e.ClickedItem.Equals( pinTypeSmd		) )	component.creationPinType = pinTypes.surface;
					if( e.ClickedItem.Equals( pinTypeThruHole	) )	component.creationPinType = pinTypes.through;
					traceHandler.componentss[i].PinType = component.creationPinType; 
				}

				Refresh();
				drawComponentMove();
   
			}	
			private void numPinsTextBox_Validated( object sender, EventArgs e )
			{
				int numPins;
				int i=traceHandler.componentss.Count()-1;
				if( i < 0 ) return;
				if( int.TryParse( sender.ToString(), out numPins ) )
				{
					traceHandler.componentss[i].reformatPins( numPins.ToString() );
				Refresh();
					drawComponentMove();
				}
			}
			private void padSizeTextBox_TextChanged( object sender, EventArgs e )
			{
				int padSize;
				int i=traceHandler.componentss.Count()-1;
				if( i < 0 ) return;
				if( int.TryParse( sender.ToString(), out padSize ) )
				{
					traceHandler.componentss[i].PadSize = padSize;
					component.creationPadSize = padSize;
					Refresh();
					drawComponentMove();
				}
			}
		private void buttonRetraceNets_Click(object sender, EventArgs e)
        {
			Console.WriteLine( "Starting net trace" );
			Stopwatch stopWatch = new Stopwatch();
			stopWatch.Start();
			traceHandler.findNetTopology();
			stopWatch.Stop();
			TimeSpan ts = stopWatch.Elapsed;
			string elapsedTime = String.Format("{0:00}:{1:00}:{2:00}.{3:000}",
				ts.Hours, ts.Minutes, ts.Seconds,
				ts.Milliseconds );
			Console.WriteLine( "Completed in {0}", elapsedTime );
		}
		private void buttonSwitchBoardLayerView_Click( object sender, EventArgs e )
		{
			int i;
			layer++;
			if( layer >= boardImages.Count() ) layer = 0;
			for( i = 0; i < boardImages.Count(); i++ )
			{
				boardImages[i].shown = ( i == layer );
			}
			textBoxLayerName.Text = boardImages[layer].layerName;
			redrawBoards();
			Refresh();
		}
		
		// Middle panel controls
		private void buttonShrinkBoard_Click(object sender, EventArgs e)
        {
            switch (panelSplitRatio)
            {
                case 0.2f:
                    break;
                case 0.5f:
                    panelSplitRatio = 0.2f;
                    break;
                case 0.8f:
                    panelSplitRatio = 0.5f;
                    break;
                default:
                    panelSplitRatio = 0.5f;
                    break;
            }
            mainFormReformat();
        }
        private void buttonShrinkCircuit_Click(object sender, EventArgs e)
        {
            switch (panelSplitRatio)
            {
                case 0.2f:
                    panelSplitRatio = 0.5f;
                    break;
                case 0.5f:
                    panelSplitRatio = 0.8f;
                    break;
                case 0.8f:
                    break;
                default:
                    panelSplitRatio = 0.5f;
                    break;
            }
            mainFormReformat();
        }
        private void button1_Click_1(object sender, EventArgs e)
        {   // KLUDGE - dev only - for triggering breakpoint
            Control control = (Control)sender;
            Point StartPoint = control.PointToScreen(new Point(0, 0));
            Console.Write("x:{0}  y:{1}", StartPoint.X, StartPoint.Y);
            zmot();
            //mainFormReformat();
        }

        // Keyboard actions
        protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            Console.WriteLine("{0} : {1}", msg, keyData);

			// Keys specific to the board display window regardless of mode
			if( boardPictureBoxActive )
			{
				switch( keyData )
				{
					case Keys.Tab:
						Console.WriteLine( "Processing TAB key" );
						buttonSwitchBoardLayerView_Click( new object(), new EventArgs() );
						keyData = Keys.None;
						break;
				}

				// Keys specific to the board display window and specific to the mouse operation mode
				switch( boardMouseMode )
				{
					case boardMouseModes.selectItem:
						switch( keyData )
						{
							case Keys.Delete:
								if( traceToolStripMenuItem.Checked )
								{
									traceHandler.deleteSegment( segmentSelectorIndex );
									segmentSelectorIndex = -1;
									redrawBoards();
									keyData = Keys.None;
								}
								if( netToolStripMenuItem.Checked )
								{
									traceHandler.deleteNet( netSelector );
									netSelector = 0;
									redrawBoards();
									keyData = Keys.None;
								}
								if( viaThruHoleToolStripMenuItem.Checked )
								{
									traceHandler.deleteVia( viaSelectorIndex );
									viaSelectorIndex = -1;
									redrawBoards();
									keyData = Keys.None;
								}
								break;
							case Keys.Escape:
								break;
						}
						break;
					case boardMouseModes.drawTrace:
						switch( keyData )
						{
							case Keys.Delete:
								drawTraceDeleteLast();
								break;
							case Keys.Escape:
								drawTraceAbort();
								keyData = Keys.None;
								break;
						}
						break;
					case boardMouseModes.insertVia:
						switch( keyData )
						{
							case Keys.Escape:
								break;
						}
						break;
					case boardMouseModes.insertThroughHole:
						switch( keyData )
						{
							case Keys.Escape:
								break;
						}
						break;
					case boardMouseModes.addComponent :
						int i = traceHandler.componentss.Count() - 1;
						float scaleX = traceHandler.componentss[i].Scale.X;
						float scaleY = traceHandler.componentss[i].Scale.Y;
						float tmpX = scaleX;
						float tmpY = scaleY;
						switch( keyData )
						{
							// Rotation of the component
							case Keys.R:
							case Keys.R | Keys.Shift:
							case Keys.R | Keys.Control:
								
								switch( keyData )
								{
									case Keys.R	:				traceHandler.componentss[i].Rotation += 90.0f; break;
									case Keys.R | Keys.Shift:	traceHandler.componentss[i].Rotation += 22.5f; break;
									case Keys.R | Keys.Control: traceHandler.componentss[i].Rotation +=  5.0f; break;
								}
								component.creationRotation = traceHandler.componentss[i].Rotation;
								Refresh();
								drawComponentMove();
								keyData = Keys.None;
								break;
							// Changing scale of the componenet
							case Keys.Right:	scaleX++; keyData = Keys.None; break;
							case Keys.Left:		scaleX--; keyData = Keys.None; break;
							case Keys.Up:		scaleY--; keyData = Keys.None; break;
							case Keys.Down:		scaleY++; keyData = Keys.None; break;

						}
						if( scaleX != tmpX || scaleY != tmpY )
						{
							if( scaleX < 1f ) scaleX = 1f;
							if( scaleY < 1f ) scaleY = 1f;
							traceHandler.componentss[i].Scale = new PointF( scaleX, scaleY );
							component.creationScale = new PointF( scaleX, scaleY );
							Refresh();
							drawComponentMove();
						}
						break;
				}
			}

			// Keys specific to the schematic display window regardless of mode
			if( circuitPictureBoxActive )
			{
				switch( keyData )
				{
					case Keys.Tab:         // although really a board action keeping it also in the schematic view as it is sometimes useful to peek at the other side of the board even when looking at the schematic
						Console.WriteLine( "Processing TAB key" );
						buttonSwitchBoardLayerView_Click( new object(), new EventArgs() );
						keyData = Keys.None;
						break;

					case Keys.R:
						Console.WriteLine( "Processing R key" );
						if( componentSelctorIndex >= 0 && sectionSelectorIndex >= 0 )
						{
							traceHandler.componentss[componentSelctorIndex].rotate( sectionSelectorIndex );
							schematic.drawSchematic( schemGraphics, traceHandler.componentss );
							Refresh();
						}
						keyData = Keys.None;
						break;
				}
			}

			if( keyData == Keys.None )
				return true;
			else
				return base.ProcessCmdKey(ref msg, keyData);
        }

        // public functions
        public int  numBoardImages()
        {   // this is mainly used just by the boardImages class during initialisation, for it to know how many instances of itself exist - there is probably a more elegant way of doing it
            return boardImages.Count;
        }
        public void setTextBoxes(string s1, string s2, string s3)
        {
            textBox1.Text = s1;
            textBox2.Text = s2;
            textBox3.Text = s3;
        }
        
        // various internal functions
        private void mainFormReformat()
        {   // Reformats the controls and stuff in the main window to fit after resizing the window

            circuitPictureBox.Width = 50;       //KLUDGE to prevent window growing out of control
            boardPictureBox.Width   = 50;       //KLUDGE to prevent window growing out of control

            int formWidth           = this.ClientRectangle.Width;

            panelLeft.Width         = leftPanelWidth;
            panelMiddle.Width       = midPanelWidth;
            panelRight.Width        = rightPanelWidth;
            panelTop.Width          = formWidth;
            panelBottom.Width       = formWidth;

            panelLeft.Left          = 0;
            panelMiddle.Left        = (int)(formWidth * panelSplitRatio) - panelMiddle.Width / 2;
            panelRight.Left         = formWidth - panelRight.Width;
            panelTop.Left           = 0;
            panelBottom.Left        = 0;

            boardPictureBox.Left    = panelLeft.Right;
            boardPictureBox.Width   = panelMiddle.Left - boardPictureBox.Left;   //(formWidth - panelLeft.Width - midPanelWidth - rightPanelWidth) / 2;
            circuitPictureBox.Left  = panelMiddle.Right;
            circuitPictureBox.Width = panelRight.Left - circuitPictureBox.Left;


            int formHeight          = this.ClientRectangle.Height;

            panelTop.Top = 1;
            panelTop.Height         = topPanelHeight;
            panelBottom.Height      = bottomPanelHeight;
            panelLeft.Top           = panelTop.Bottom;
            panelMiddle.Top         = panelTop.Bottom;
            panelRight.Top          = panelTop.Bottom;

            boardPictureBox.Top     = panelTop.Bottom;
            circuitPictureBox.Top   = panelTop.Bottom;

            panelBottom.Top         = formHeight - panelBottom.Height;
            panelLeft.Height        = panelBottom.Top - panelTop.Bottom;
            panelMiddle.Height      = panelBottom.Top - panelTop.Bottom;
            panelRight.Height       = panelBottom.Top - panelTop.Bottom;
            boardPictureBox.Top     = panelTop.Bottom;
            boardPictureBox.Height  = panelBottom.Top - panelTop.Bottom;
            circuitPictureBox.Top   = panelTop.Bottom; ;
            circuitPictureBox.Height= panelBottom.Top - panelTop.Bottom;


			
			boardBitMap =    new Bitmap( boardPictureBox.ClientRectangle.Width, boardPictureBox.ClientRectangle.Height );
			boardPictureBox.Image = boardBitMap;
			boardGraphics = Graphics.FromImage( boardPictureBox.Image );

			schemBitMap = new Bitmap( circuitPictureBox.ClientRectangle.Width, circuitPictureBox.ClientRectangle.Height );
			circuitPictureBox.Image = schemBitMap;
			schemGraphics = Graphics.FromImage( circuitPictureBox.Image );

			Refresh();

			redrawBoards();
			schematic.drawSchematic( schemGraphics, traceHandler.componentss );
			Refresh();
		}
        private void redrawBoards( bool quick = false )
        {   // redraws the board views - called after zoomig, scrolling, resizing the main window and so on
            if (this.Visible)
            {
                //// KLUDGE REMOVE!  development only
                //boardImages[1].correctionX = float.Parse(textBox1.Text);
                //boardImages[1].correctionY = float.Parse(textBox2.Text);
                //boardImages[1].correctionScale = float.Parse(textBox3.Text);
                ////

                for (int i = 0; i < boardImages.Count; i++)
                {
                    boardImages[i].drawImage(boardPictureBox, boardGraphics);
                }
            }

            // Redraw the traces, components and such, unless we are in fast redrwaing mode (which draws only the board images)
            if (!quick)
            {
                traceRedrawAll();
				viasRedraw();
				componentsRedraw();
				if ( netSelector != 0)              traceRedrawSelectedNet();
                if ( segmentSelectorIndex  != -1)   traceRedrawSelectedSegment ();
            }
  
            // Redraw the trace that is currenly being added, if any
            drawTraceRedrawCurrent();

			Refresh();

            //tracePointFlag1 = false;				 // this is probably not needed anymore after replacing the 'DrawReversible' method with the new one.
        }
		private void openFile( string fileName)
		{
			Console.WriteLine( ">>>Loading project" );
			StreamReader reader = new StreamReader( fileName );
			traceHandler.readSegments( reader );
			traceHandler.readVias( reader );
			boardImage.readConfig( reader, boardImages, this );
			component.readComponents( reader, traceHandler.componentss );
			reader.Close();
			Console.WriteLine( ">>>Ready" );
			traceHandler.findNetTopology();
			redrawBoards();
		}

		// Item selection on the board image
		private void selectItemClick(object sender, MouseEventArgs e)
        {
            bool needRedraw = false;
            // the co-ordinates of the point we need to identify
            PointF searchPoint = boardImages[0].boardCoordFromScreenCoord(new PointF(e.X, e.Y));

            // Select a trace
            if (traceToolStripMenuItem.Checked)
            {
                int prevTraceSelector = segmentSelectorIndex;
                segmentSelectorIndex = traceHandler.findSegmentIndexAt(searchPoint, layer);
                Console.WriteLine("Selected trace (segment) {0}", segmentSelectorIndex);
                if (segmentSelectorIndex != prevTraceSelector)
                    needRedraw = true;
            }
            // Select a net
            if (netToolStripMenuItem.Checked)
            {
                int prevNetSelector = netSelector;
                netSelector = traceHandler.findNetIndexAt(searchPoint, layer);
                Console.WriteLine("Selected net {0}", netSelector);
                if (netSelector != prevNetSelector)
                    needRedraw = true;
            }
            // Select a via
            if (viaThruHoleToolStripMenuItem.Checked)
            {
                int prevViaSelectorIndex = viaSelectorIndex;
                viaSelectorIndex = traceHandler.findViaIndexAt(searchPoint);
                Console.WriteLine("Selected Via {0}", viaSelectorIndex);
                if (viaSelectorIndex != prevViaSelectorIndex)
                    needRedraw = true;
            }

            if ( needRedraw ) redrawBoards();
        }

        // Trace drawing and editing
        private void drawTraceClick(object sender, MouseEventArgs e)
        {
            if ( tracePoints.Count >=2)     // >=2 means a trace already exists and we add points to it. If not >=2 then we are staring a new trace
            {
                if (tracePoints[tracePoints.Count()-2] == boardImages[0].boardCoordFromScreenCoord( new PointF(e.X,e.Y) ))      // if user clicks on same point twice it means the trace is completed
                {
                    Console.WriteLine ("Completing and storing trace");
                    traceHandler.addTrace(tracePoints, layer,0);
                    tracePoints.Clear();                    
                    return;
                }
            }
            else
            {
                Console.WriteLine("Starting new trace");
                tracePoints.Add(boardImages[0].boardCoordFromScreenCoord(new PointF(e.X, e.Y)));
                
            }
            Console.WriteLine("Add point to trace and refresh display");
            tracePoints.Add(boardImages[0].boardCoordFromScreenCoord(new PointF(e.X, e.Y)));
            drawTraceRedrawCurrent();       
        }	
		private void drawTraceMove(object sender, MouseEventArgs e)
        {
            //textBox1.Text = tracePoints.Count().ToString();
            if (tracePoints.Count >= 2)     // >=2 means a trace already exists and we add points to it. If not >=2 then there is no trace so nothing to be done
            {
                Control control = (Control)sender;
                Point startPoint, endPoint;
                Point offset;
                //int dx, dy;

                //if (tracePointFlag1)
                //{  
                //    int i = tracePoints.Count() - 2;
                //    startPoint = boardImages[0].screenCoordFromBoardCoord(tracePoints[i]);
                //    endPoint   = boardImages[0].screenCoordFromBoardCoord(tracePoints[i + 1]);
                //    constrainLineWithin(ref startPoint, ref endPoint, boardPictureBox.ClientRectangle.Size);

                //    startPoint = control.PointToScreen(startPoint);
                //    endPoint =   control.PointToScreen(endPoint);
                //    ControlPaint.DrawReversibleLine(startPoint, endPoint, Color.Cyan);

                //    offset = perpendicularOffset(startPoint, endPoint, 2);
                //    startPoint.Offset(offset);
                //    endPoint.Offset(offset);
                //    ControlPaint.DrawReversibleLine(startPoint, endPoint, Color.Magenta  );

                //    offset = perpendicularOffset(startPoint, endPoint, -4);
                //    startPoint.Offset(offset);
                //    endPoint.Offset(offset);
                //    ControlPaint.DrawReversibleLine(startPoint, endPoint, Color.Yellow);
                //}
                //tracePoints.RemoveAt(tracePoints.Count()-1);
                //tracePoints.Add( boardImages[0].boardCoordFromScreenCoord(new Point(e.X, e.Y)));
                tracePoints[tracePoints.Count() - 1] = boardImages[0].boardCoordFromScreenCoord(new Point(e.X, e.Y));
                {
					//int i = tracePoints.Count() - 2;
					//startPoint = boardImages[0].screenCoordFromBoardCoord( tracePoints[i]     );
					//endPoint   = boardImages[0].screenCoordFromBoardCoord( tracePoints[i + 1] );
					//constrainLineWithin(ref startPoint, ref endPoint, boardPictureBox.ClientRectangle.Size);
					//startPoint = control.PointToScreen( startPoint);
					//endPoint   = control.PointToScreen( endPoint  );                    
					//ControlPaint.DrawReversibleLine(startPoint, endPoint, Color.Cyan);

					//offset = perpendicularOffset(startPoint, endPoint, 2);
					//startPoint.Offset(offset);
					//endPoint.Offset(offset);
					//ControlPaint.DrawReversibleLine(startPoint, endPoint, Color.Magenta );

					//offset = perpendicularOffset(startPoint, endPoint, -4);
					//startPoint.Offset(offset);
					//endPoint.Offset(offset);
					//ControlPaint.DrawReversibleLine(startPoint, endPoint, Color.Yellow);

					Graphics destImage = boardPictureBox.CreateGraphics();
					Pen myPen = new Pen( System.Drawing.Color.Green, 1 );

					int i = tracePoints.Count() - 2;
					startPoint = boardImages[0].screenCoordFromBoardCoord( tracePoints[i] );
					endPoint = boardImages[0].screenCoordFromBoardCoord( tracePoints[i + 1] );
					constrainLineWithin( ref startPoint, ref endPoint, boardPictureBox.ClientRectangle.Size );

					destImage.DrawLine( new Pen( System.Drawing.Color.White, 3 ), startPoint, endPoint );

					offset = perpendicularOffset( startPoint, endPoint, 2 );
					startPoint.Offset( offset );
					endPoint.Offset( offset );
					destImage.DrawLine( new Pen( System.Drawing.Color.Black, 2 ), startPoint, endPoint );

					offset = perpendicularOffset( startPoint, endPoint, -4 );
					startPoint.Offset( offset );
					endPoint.Offset( offset );
					destImage.DrawLine( new Pen( System.Drawing.Color.Black, 2 ), startPoint, endPoint );
				}
				//tracePointFlag1 = true;
            }
        }
        private void drawTraceAbort()
        {
            tracePoints.Clear();
            redrawBoards();
            //boardMouseMode = boardMouseModes.none;
        }
        private void drawTraceDeleteLast()
        {
            if (tracePoints.Count() >= 3)
            {
                Console.WriteLine("Deleted last point from trace");
                tracePoints.RemoveAt(tracePoints.Count() - 1);
            }
            else
            {
                tracePoints.Clear();
                Console.WriteLine("Cleared trace");
            }
            redrawBoards();
        }
        private void drawTraceRedrawCurrent()
        {
            if (tracePoints.Count() > 2)
            {
                Graphics graphicsObj;
				graphicsObj = boardGraphics; // boardPictureBox.CreateGraphics();
                Pen myPen = new Pen(traceColour[layer], 5);
                for (int i = 0; i < tracePoints.Count() - 2; i++)
                {
                    graphicsObj.DrawLine
                    (
                        myPen,
                        boardImages[0].screenCoordFromBoardCoord(tracePoints[i]),
                        boardImages[0].screenCoordFromBoardCoord(tracePoints[i + 1])
                    );
                }
            }
        }
        private void traceRedrawAll() { traceRedrawAll( Color.AliceBlue); }
        private void traceRedrawAll(Color colour, int thickness = 0, int selectedNet = 0, int selectedSegmentIndex=-1  )
        {
            //Stopwatch stopWatch = new Stopwatch();
            //stopWatch.Start();
			if ( boardGraphics == null ) { Console.WriteLine( "NULL boardgraphics" ); return; }
			//if (selectedNet != 0) Console.WriteLine("Redrawing with Selected net: {0}", selectedNet);
				if (traceHandler.segmentList.Count() != 0 )
            {
                Graphics graphicsObj;
				graphicsObj = boardGraphics; // boardPictureBox.CreateGraphics();
                if (colour.Equals(Color.AliceBlue)) colour = traceColour[layer];
                Pen myPen = new Pen( colour, thickness * boardImages[0].scale  );
                for (int i = 0; i < traceHandler.segmentList.Count; i++)
                {
                    bool                                                    show = true;
                    
                    if ( selectedNet != 0 | selectedSegmentIndex != -1)     show = false;
                    if ( traceHandler.segmentList[i].net == selectedNet)    show = true;
                    if ( i == selectedSegmentIndex)                         show = true;
                    if (traceHandler.segmentList[i].layer != layer)         show = false;
                    //if (traceHandler.segmentList[i].layer == layer & ( selectedNet == 0 | traceHandler.segmentList[i].net == selectedNet))
                    if ( show )
                    {
                        if (thickness == 0) myPen.Width = traceHandler.segmentList[i].thickness * boardImages[0].scale;
                        for (int j = 0; j < traceHandler.segmentList[i].pointList.Count() - 1; j++)
                        {
							graphicsObj.DrawLine		      
                            (
                                myPen,
                                boardImages[0].screenCoordFromBoardCoord(traceHandler.segmentList[i].pointList[j]),
                                boardImages[0].screenCoordFromBoardCoord(traceHandler.segmentList[i].pointList[j + 1])
                            );
                        }
                    }
                }
            }
			Refresh();
            //stopWatch.Stop();
            //TimeSpan ts = stopWatch.Elapsed;
            //string elapsedTime = String.Format("{0:00}:{1:00}:{2:00}.{3:000}",
            //    ts.Hours, ts.Minutes, ts.Seconds,
            //    ts.Milliseconds / 10);
            //Console.WriteLine("RunTime {0}", elapsedTime );
        }
        private void traceRedrawSelectedSegment()
        {
            traceRedrawAll(colour: Color.Orange, thickness: 5, selectedSegmentIndex: segmentSelectorIndex);
        }
        private void traceRedrawSelectedNet()
        {
            traceRedrawAll(colour: Color.Red, thickness: 5, selectedNet: netSelector);
        }
        private void traceDeleteSelectedLine() { }
        private void traceDeleteSelectedTrace() { }
       
        // Vias and throughHoles
        private void insertViaClick( object sender, MouseEventArgs e)
        {
            traceHandler.AddVia(boardImages[0].boardCoordFromScreenCoordF(new PointF(e.X, e.Y)),15);
            viasRedraw(last: true);
        }
        private void viasRedraw(bool last = false)
        {
			if ( boardGraphics == null ) { Console.WriteLine( "NULL boardGraphics redrawing Vias" ); return; }
			int i, start, end;
            float scale = boardImages[0].scale;
            end = traceHandler.viaList.Count() - 1;
            if ( last ) start = end; else start = 0;
            Graphics graphicsObj;
			graphicsObj = boardGraphics; // boardPictureBox.CreateGraphics();
            for (i = start; i<= end; i++)
            {
                float halfThickness = traceHandler.viaList[i].size * 0.1F;
                float outerRadius   = traceHandler.viaList[i].size * 0.5f - halfThickness ;
                float innerRadius   = traceHandler.viaList[i].size * 0.1f + halfThickness;
                
                Pen myPen = new Pen(Color.Black, halfThickness * 2F * scale);
                if (i == viaSelectorIndex) myPen.Color = Color.Red;
                graphicsObj.DrawEllipse 
                (
                    myPen,
                    boardImages[0].screenCoordFromBoardCoord(traceHandler.viaList[i].location).X-outerRadius * scale ,
                    boardImages[0].screenCoordFromBoardCoord(traceHandler.viaList[i].location).Y-outerRadius * scale,
                    outerRadius * scale * 2, outerRadius * scale * 2
                );
                myPen.Color=Color.White;
                if (i == viaSelectorIndex) myPen.Color = Color.Green;
                graphicsObj.DrawEllipse
                (
                    myPen,
                    boardImages[0].screenCoordFromBoardCoord(traceHandler.viaList[i].location).X - innerRadius * scale,
                    boardImages[0].screenCoordFromBoardCoord(traceHandler.viaList[i].location).Y - innerRadius * scale,
                    innerRadius * scale * 2, innerRadius * scale * 2
                );

            }
            
        }

		// Components on the board view
		private void componentsRedraw( bool last = false )
		{
			PointF boardPoint, displayPoint;

			float scale = boardImages[0].scale; if( boardGraphics == null ) { Console.WriteLine( "NULL boardGraphics redrawing Components" ); return; }
			int i, start, end;
			
			end = traceHandler.componentss.Count() - 1;
			start = 0; //if( last ) start = end; else start = 0;
			Graphics graphicsObj;
			graphicsObj = boardGraphics; // boardPictureBox.CreateGraphics();
			for( i = start; i <= end; i++ )
			{
				if( traceHandler.componentss[i].layer == layer && !traceHandler.componentss[i].hidden )
				{
					boardPoint = traceHandler.componentss[i].position;
					//Pen myPen = new Pen(Color.Black, 5 * scale);
					//if( i == componentSelectorIndex ) myPen.Color = Color.Red;
					displayPoint = boardImages[0].screenCoordFromBoardCoord( boardPoint );                 // the position within the display
					traceHandler.componentss[i].boardDraw( graphicsObj, displayPoint, scale, selected : ( componentSelctorIndex == i ) );
					
				}
				if( traceHandler.componentss[i].layer != layer && !traceHandler.componentss[i].hidden && traceHandler.componentss[i].PinType == pinTypes.through )
				{
					boardPoint = traceHandler.componentss[i].position;
					//Pen myPen = new Pen(Color.Black, 5 * scale);
					//if( i == componentSelectorIndex ) myPen.Color = Color.Red;
					displayPoint = boardImages[0].screenCoordFromBoardCoord( boardPoint );                 // the position within the display
					traceHandler.componentss[i].boardDraw( graphicsObj, displayPoint, scale, backPinsOnly : true );

				}
			}

		}
		private void drawComponentMove( int x = int.MinValue , int y = int.MinValue  )
		{
			int i=traceHandler.componentss.Count()-1;	
			if( i >= 0 )
			{
				Point boardPoint, displayPoint;
				Graphics destImage = boardPictureBox.CreateGraphics();
				Pen myPen = new Pen( System.Drawing.Color.Green, 3 );
				float scale = boardImages[0].scale;
				if( x != int.MinValue && y != int.MinValue )
				{
					boardPoint = boardImages[0].boardCoordFromScreenCoord( new Point( x, y ) );        // the position within the board
					traceHandler.componentss[i].position = boardPoint;
				}
				else
					boardPoint = new Point( (int)traceHandler.componentss[i].position.X, (int)traceHandler.componentss[i].position.Y ) ;
				displayPoint = boardImages[0].screenCoordFromBoardCoord( boardPoint );                 // the position within the displaytraceHandler.componentss[i].position = boardPoint;
				traceHandler.componentss[i].layer = layer;
				if( layer == 0 ) traceHandler.componentss[i].Mirror = MIRROR.none;  // KLUDGE
				else traceHandler.componentss[i].Mirror = MIRROR.horizontal;        // KLUDGE
				traceHandler.componentss[i].boardDraw( destImage, displayPoint, scale );
			}
		}
		private void addComponentStart(  )	 // This is called when component insertion mode is selected
		{
			traceHandler.componentss.Add( new component(  new PointF( 0, 0 ) ) );
			traceHandler.componentss[traceHandler.componentss.Count() - 1].hidden = true;
		}
		private void addComponentClick( object sender, MouseEventArgs e )
		{
			int i=traceHandler.componentss.Count() - 1;
			// Confirm and complete the addition of the component that was being created
			if( i >= 0 )
			{
				traceHandler.componentss[i].position = boardImages[0].boardCoordFromScreenCoordF( new PointF( e.X, e.Y ) );
				traceHandler.componentss[i].layer = layer;
				if( layer == 0 ) traceHandler.componentss[i].Mirror = MIRROR.none;  // KLUDGE
				else traceHandler.componentss[i].Mirror = MIRROR.horizontal;        // KLUDGE
				traceHandler.componentss[i].hidden = false;
				traceHandler.componentss[i].sections[0].position = new PointF( traceHandler.componentss[i].position.X * 10, traceHandler.componentss[i].position.Y * 10);   // KLUDGE
				traceHandler.componentss[i].reformatPins( "" );
			}
			// Create a new floating component
			traceHandler.componentss.Add( new component( boardImages[0].boardCoordFromScreenCoordF( new PointF( e.X, e.Y ) ) ) );
			i = traceHandler.componentss.Count() - 1;
			traceHandler.componentss[i].layer = layer;
			if( layer == 0 ) traceHandler.componentss[i].Mirror = MIRROR.none;       // KLUDGE
			else traceHandler.componentss[i].Mirror = MIRROR.horizontal;             // KLUDGE
			traceHandler.componentss[i].hidden = true;
			componentsRedraw( last: true );
		}
		private void addComponentAbort( )
		{
			int i=traceHandler.componentss.Count() - 1;
			if ( i>= 0 ) traceHandler.componentss.RemoveAt( i );
		}
		
		// generic helper functions
		private Point perpendicularOffset(Point startPoint, Point endPoint, int radius)
        {
            int dx = endPoint.X - startPoint.X;
            int dy = endPoint.Y - startPoint.Y;

            double length = Math.Sqrt(dx * dx + dy * dy);

            return new Point { X = (int)((dy * radius) / length), Y = -(int)((dx * radius) / length) };

            }
        private void  constrainLineWithin( ref Point startPoint, ref Point endPoint, Size size)
        {   // trims the ends of a line to fit within a rectangle
            // the rectangle is assumed to always originate at 0,0 since only the size is specified
            // can easily be modified to work for any rectangle by putting the edges of the rectabgle
            // in bx1,by1,bx2,by2 instead of putting zeros int bx1,bx2 and size in bx2,by2

            float lx1, ly1, lx2, ly2;  // co-ordinates of start and end of line
            float bx1, by1, bx2, by2;  // boundaries of window
            //float a, b, c, d;          // coefficients for the line equation (x-c)/a=(y-d/b)
            float resizeRatio;

            lx1 = startPoint.X;
            ly1 = startPoint.Y;
            lx2 = endPoint.X;
            ly2 = endPoint.Y;
            bx1 = 0;
            by1 = 0;
            bx2 = size.Width - 1;
            by2 = size.Height - 1;

            if (lx1 < bx1)    // startpoint is to the left of the border
            {
                resizeRatio = (lx2 - bx1) / (lx2 - lx1);
                lx1 = lx2 - (lx2 - lx1) * resizeRatio;
                ly1 = ly2 - (ly2 - ly1) * resizeRatio;
            }
            if (lx1 > bx2)    // startpoint is to the right of the border
            {
                resizeRatio = (lx2 - bx2) / (lx2 - lx1);
                lx1 = lx2 - (lx2 - lx1) * resizeRatio;
                ly1 = ly2 - (ly2 - ly1) * resizeRatio;
            }
            if (lx2 < bx1)    // endpoint is to the left of the border
            {
                resizeRatio = (lx1 - bx1) / (lx1 - lx2);
                lx2 = lx1 - (lx1 - lx2) * resizeRatio;
                ly2 = ly1 - (ly1 - ly2) * resizeRatio;
            }
            if (lx2 > bx2)    // endpoint is to the right of the border
            {
                resizeRatio = (lx1 - bx2) / (lx1 - lx2);
                lx2 = lx1 - (lx1 - lx2) * resizeRatio;
                ly2 = ly1 - (ly1 - ly2) * resizeRatio;
            }
            if (ly1 < by1)    // startpoint is above the border
            {
                resizeRatio = (ly2 - by1) / (ly2 - ly1);
                ly1 = ly2 - (ly2 - ly1) * resizeRatio;
                lx1 = lx2 - (lx2 - lx1) * resizeRatio;
            }
            if (ly1 > by2)    // startpoint is below the border
            {
                resizeRatio = (ly2 - by2) / (ly2 - ly1);
                ly1 = ly2 - (ly2 - ly1) * resizeRatio;
                lx1 = lx2 - (lx2 - lx1) * resizeRatio;
            }
            if (ly2 < by1)    // endpoint is above the border
            {
                resizeRatio = (ly1 - by1) / (ly1 - ly2);
                ly2 = ly1 - (ly1 - ly2) * resizeRatio;
                lx2 = lx1 - (lx1 - lx2) * resizeRatio;
            }
            if (ly2 > by2)    // endpoint is below the border
            {
                resizeRatio = (ly1 - by2) / (ly1 - ly2);
                ly2 = ly1 - (ly1 - ly2) * resizeRatio;
                lx2 = lx1 - (lx1 - lx2) * resizeRatio;
            }
            startPoint.X = (int)lx1;
            startPoint.Y = (int)ly1;
            endPoint.X = (int)lx2;
            endPoint.Y = (int)ly2;
        }
		private bool menuItemHilite( ToolStripItemClickedEventArgs e, List<ToolStripItem> tSIList )
		{	// change the highlighting of an item specified in the event within the specified list of menu items. Returns true if the item is in the list or false if it isn't
			bool itemClicked = false;
			foreach( ToolStripItem cI in tSIList )
			{
				if( e.ClickedItem.Equals( cI ) ) itemClicked = true;
			}
			if( itemClicked )
			{
				foreach( ToolStripItem cI in tSIList )
				{
					cI.ForeColor = Color.Black;
					cI.BackColor = SystemColors.Control;
					if( e.ClickedItem.Equals( cI ) )
					{
						cI.BackColor = Color.Black;
						cI.ForeColor = Color.White;
						Console.WriteLine( ">{0}:{1}", cI.Name, e.ClickedItem.Equals( cI ) );
					}
				}
			}
			return itemClicked;
		}
        
		// some stuff for trying out language syntax and such - zmot is called when the 'exclamation' button is pressed
        private void zmot()
        {
            Console.WriteLine("TEST BUTTON PRESSED");
			schematic.drawSchematic( schemGraphics, traceHandler.componentss );

		}
        private void hScrollNetSelector_Scroll(object sender, ScrollEventArgs e)
        {
            if (hScrollNetSelector.Maximum != traceHandler.netList.Count())
                hScrollNetSelector.Maximum = traceHandler.netList.Count();
            if (hScrollNetSelector.Value == netSelectorIndex  )
                return;
            Console.WriteLine("hScrollNetSelector_Scroll {0} -> {1}", e.OldValue ,e.NewValue);
            if (netSelectorIndex != 0)
            {
                Console.WriteLine("Erasing previous net {0} display", netSelector);
                netSelectorIndex = 0;
                traceRedrawAll();
            }
            netSelectorIndex = hScrollNetSelector.Value;
            Console.WriteLine("Drawing net {0} display (index {1})", netSelector,netSelectorIndex );
            if (netSelectorIndex != 0)
            {
                netSelector = traceHandler.netList[netSelectorIndex];
                traceRedrawSelectedNet();
            }
            else
                traceRedrawAll();
        }
	}
}

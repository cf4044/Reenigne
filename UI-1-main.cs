using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

 
namespace Reenigne
{  
#pragma warning disable IDE1006

	public partial class mainForm : Form
	{				
		kSymbol sym = new kSymbol();             // KLUDGE  dev only
		public static bool quit;

		// Main form initialisation
		public mainForm()
		{
			InitializeComponent();      // This is generated by the forms designer - do not alter or remove. here 'Componennt' is to do with Windows, not the electronic components this project is about.  
			
			// Add event handlers for the board picture box
			boardPictureBox.MouseDown  += boardPictureBox_MouseDown;
			boardPictureBox.MouseMove  += boardPictureBox_Move;
			boardPictureBox.MouseClick += boardPictureBox_Click;
			boardPictureBox.MouseEnter += boardPictureBox_MouseEnter;
			boardPictureBox.MouseLeave += boardPictureBox_MouseLeave;
			boardPictureBox.MouseWheel += boardPictureBox_MouseWheel;

			// Add event handlers for the schematic picture box
			circuitPictureBox.MouseDown  += circuitPictureBox_MouseDown;
			circuitPictureBox.MouseMove  += circuitPictureBox_Move;
			circuitPictureBox.MouseClick += circuitPictureBox_Click;
			circuitPictureBox.MouseEnter += circuitPictureBox_MouseEnter;
			circuitPictureBox.MouseLeave += circuitPictureBox_MouseLeave;
			circuitPictureBox.MouseWheel += circuitPictureBox_MouseWheel;

			//ContextMenu boardContextMenu = new ContextMenu();
			//boardContextMenu.MenuItems.Add("Item 1", new EventHandler(boardItem1_Click));
			//boardContextMenu.MenuItems.Add("Item 2", new EventHandler(boardItem2_Click));
			//boardPictureBox.ContextMenu = boardContextMenu;

			//===============================================================================
			// Set up  the handler for communication from other forms
			//-------------------------------------------------------------------------------
			glob.progress = new Progress<string>
			(
				( string p ) =>
				{
					Console.WriteLine( "Progress[A]:{0}", p );
					switch ( p )
					{
						case "Schematic symbol changed":
							schem.drawSchematic( schemGraphics, traceHandler.componentss /* quick: true*/ );
							Refresh();
							break;
						case "Board image changed":
							Console.WriteLine( "ZZZZZZZZZZZZZZ" );
							redrawBoards();
							break;
					}
				}
			);

			// Read settings from registry, if there are any already existing
			readRegistry();

			updateFormTitle();
			quit = true;    // This means that any closing of the main window will quit the program unless explicitly cleared, such as for example when closing the form to re-open the project	rather than to exit
			createEmptyProject();
			mainFormReformat();		
		}

		//Actions relating the the main form - opening, closing, resizing etc
		private void mainForm_Load( object sender, EventArgs e )
		{

		}
		private void mainForm_Shown( object sender, EventArgs e )
		{
			Top = 559;
			Left = 175;
			Width = 2359;
			Height = 1223;
			redrawBoards();
			Refresh();
		}
		private void mainForm_Activated( object sender, EventArgs e )
		{
			//redrawBoards();
		}
		private void mainForm_ResizeEnd( object sender, EventArgs e )
		{
			Console.WriteLine( "Main window resized to {0},{1},{2},{3} (top/left/width/height)", Top, Left, Width, Height );
		}
		private void mainForm_Resize( object sender, EventArgs e )
		{
			mainFormReformat();
			//if (WindowState == FormWindowState.Maximized && !wasMaximized)
			//{ mainFormReformat(); wasMaximized = true;  return; };

			//if (WindowState != FormWindowState.Maximized &&  wasMaximized)
			//{ mainFormReformat(); wasMaximized = false; return; };
		}
		protected override void OnFormClosing( FormClosingEventArgs e )
		{
			writeRegistry();	
		}

		// Top panel controls
		private void buttonSave_Click( object sender, EventArgs e )
		{
			saveProject();
		}
		private void buttonCheckPoint_Click( object sender, EventArgs e )
		{
			saveCheckPoint();
		}
		private void buttonOpen_Click( object sender, EventArgs e )
		{
			//glob.projectName = "exampleProject";
			readRegistry();
			string fileName = glob.projectFolder + "\\" + glob.projectName+ glob.projectFileSuffix ;
			openProject( fileName );   
		}
		private void buttonRefresh_Click( object sender, EventArgs e )
		{   // this is just a temporary thing for development - should not be needed in the finished product
			redrawBoards();
		}

		// Left panel controls
		private void radioButtonModeSelect_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModeSelect.Checked )
			{
				boardMouseMode = boardMouseModes.selectItem;
			}
		}
			private void contextMenuSelectionType_ItemClicked( object sender, ToolStripItemClickedEventArgs e )
			{
				if( e.ClickedItem.Equals( allToolStripMenuItem ) || e.ClickedItem.Equals( noneToolStripMenuItem ) )
				{
					pointToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					lineToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					traceToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					netToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					viaThruHoleToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
					componentToolStripMenuItem.Checked = e.ClickedItem.Equals( allToolStripMenuItem );
				}
			}
		private void radioButtonModeDrawTrace_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModeDrawTrace.Checked )
			{
				boardMouseMode = boardMouseModes.drawTrace;
			}
			else
			{
				drawTraceAbort();
			}
		}
		private void radioButtonModeDropVia_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModeDropVia.Checked )
			{
				boardMouseMode = boardMouseModes.insertVia;
			}
		}
		private void radioButtonModeDropThroughHole_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModeDropThroughHole.Checked )
			{
				boardMouseMode = boardMouseModes.insertThroughHole;
			}
		}
		private void radioButtonModePlaceComponent_CheckedChanged( object sender, EventArgs e )
		{
			if( radioButtonModePlaceComponent.Checked )
			{
				boardMouseMode = boardMouseModes.addComponent;
				addComponentStart( );
			}
			else
			{
				addComponentAbort();
			}
		}
			private void contextMenuComponentType_ItemClicked( object sender, ToolStripItemClickedEventArgs e )
			{
				Console.WriteLine( "ComponentT type menu {0}",e.ClickedItem.ToString() );
				int i=traceHandler.componentss.Count()-1;
				if( i < 0 ) return;
				if 
				(
					menuItemHilite( e, new List<ToolStripItem> { compTypeSIL, compTypeDIL, compTypeCircular, compTypeSquare } )
					||
					menuItemHilite( e, new List<ToolStripItem> { outlineHeader, outlineRectangular, outlineCircular } )
				)
				traceHandler.componentss[i].reformatPins( e.ClickedItem.Name );

				if ( menuItemHilite( e, new List<ToolStripItem> { pinTypeSmd, pinTypeThruHole } ) )
				{
					if( e.ClickedItem.Equals( pinTypeSmd		) )	component.creationPinType = pinTypes.surface;
					if( e.ClickedItem.Equals( pinTypeThruHole	) )	component.creationPinType = pinTypes.through;
					traceHandler.componentss[i].PinType = component.creationPinType; 
				}

				Refresh();
				drawComponentMove();
   
			}	
			private void numPinsTextBox_Validated( object sender, EventArgs e )
			{
				int i=traceHandler.componentss.Count()-1;
				if( i < 0 ) return;
				if( int.TryParse( sender.ToString(), out int numPins ) )
				{
					traceHandler.componentss[i].reformatPins( numPins.ToString() );
					Refresh();
					drawComponentMove();
				}
			}
			private void padSizeTextBox_TextChanged( object sender, EventArgs e )
			{
			int i=traceHandler.componentss.Count()-1;
			if( i < 0 ) return;
				if( int.TryParse( sender.ToString(), out int padSize ) )
				{
					traceHandler.componentss[i].PadSize = padSize;
					component.creationPadSize = padSize;
					Refresh();
					drawComponentMove();
				}
			}
		private void buttonRetraceNets_Click(object sender, EventArgs e)
        {
			Console.WriteLine( "Starting net trace" );
			Stopwatch stopWatch = new Stopwatch();
			stopWatch.Start();
			traceHandler.findNetTopology();
			stopWatch.Stop();
			TimeSpan ts = stopWatch.Elapsed;
			string elapsedTime = String.Format("{0:00}:{1:00}:{2:00}.{3:000}",
				ts.Hours, ts.Minutes, ts.Seconds,
				ts.Milliseconds );
			Console.WriteLine( "Completed in {0}", elapsedTime );
		}
		private void buttonSwitchBoardLayerView_Click( object sender, EventArgs e )
		{
			int i;
			layerInfo lyr;
			if( layer + 1 < traceHandler.layers.Count() ) layer++; else layer = 0;
			// note: changing the value of layer automatically triggers a redraw
		}
		
		// Middle panel controls
		private void buttonShrinkBoard_Click(object sender, EventArgs e)
        {
            switch (panelSplitRatio)
            {
                case 0.2f:
                    break;
                case 0.5f:
                    panelSplitRatio = 0.2f;
                    break;
                case 0.8f:
                    panelSplitRatio = 0.5f;
                    break;
                default:
                    panelSplitRatio = 0.5f;
                    break;
            }
            mainFormReformat();
        }
        private void buttonShrinkCircuit_Click(object sender, EventArgs e)
        {
            switch (panelSplitRatio)
            {
                case 0.2f:
                    panelSplitRatio = 0.5f;
                    break;
                case 0.5f:
                    panelSplitRatio = 0.8f;
                    break;
                case 0.8f:
                    break;
                default:
                    panelSplitRatio = 0.5f;
                    break;
            }
            mainFormReformat();
        }
        private void button1_Click_1(object sender, EventArgs e)
        {   // KLUDGE - dev only - for triggering breakpoint
            Control control = (Control)sender;
            Point StartPoint = control.PointToScreen(new Point(0, 0));
            Console.Write("x:{0}  y:{1}", StartPoint.X, StartPoint.Y);
            zmot();
            //mainFormReformat();
        }
		private void buttonCompDataSet_Click( object sender, EventArgs e )
		{
			if( componentSelectorIndex >= 0 )
			{
				traceHandler.componentss[componentSelectorIndex].desigType = textBoxDesigType.Text;
				int.TryParse( textBoxDesigNum.Text, out traceHandler.componentss[componentSelectorIndex].desigNum );
				if( traceHandler.componentss[componentSelectorIndex].symbol != null )
				{
					traceHandler.componentss[componentSelectorIndex].symbol.name = textBoxComponentName.Text;
				}
			}
		}
		
		// Keyboard actions
		protected override bool ProcessCmdKey(ref Message msg, Keys keyData)
        {
            Console.WriteLine("{0} : {1}", msg, keyData);

			// Keys specific to the board display window regardless of mode
			if( boardPictureBoxActive )
			{
				switch( keyData )
				{
					case Keys.Tab:
						Console.WriteLine( "Processing TAB key" );
						buttonSwitchBoardLayerView_Click( new object(), new EventArgs() );
						keyData = Keys.None;
						break;
				}

				// Keys specific to the board display window and specific to the mouse operation mode
				switch( boardMouseMode )
				{
					case boardMouseModes.selectItem:			// Actions to be done on selections
						switch( keyData )
						{
							case Keys.Delete:
								if( traceToolStripMenuItem.Checked )
								{
									traceHandler.deleteSegment( segmentSelectorIndex );
									segmentSelectorIndex = -1;
									redrawBoards();
									keyData = Keys.None;
								}
								if( netToolStripMenuItem.Checked )
								{
									traceHandler.deleteNet( netSelector );
									netSelector = 0;
									netSelectorIndex = -1;
									redrawBoards();
									keyData = Keys.None;
								}
								if( viaThruHoleToolStripMenuItem.Checked )
								{
									traceHandler.deleteVia( viaSelectorIndex );
									viaSelectorIndex = -1;
									redrawBoards();
									keyData = Keys.None;
								}
								if ( componentToolStripMenuItem.Checked )
								{
									traceHandler.deleteComponent( componentSelectorIndex );
									componentSelectorIndex = -1;
									redrawBoards();
									keyData = Keys.None;
								}
								break;
							case Keys.R:   // Rotate a selecetd component
								if( componentToolStripMenuItem.Checked && componentSelectorIndex >= 0 )
								{
									traceHandler.componentss[componentSelectorIndex].Rotation += 90.0f;
									redrawBoards();
									keyData = Keys.None;
								}
								break;
							case Keys.M:	// Move the selected component to the current cursor position
								if( componentToolStripMenuItem.Checked && componentSelectorIndex >= 0 )
								{
									Point mouseScreenPos = Cursor.Position;										// Get global mouse position																																	
									Point mouseClientPos = boardPictureBox.PointToClient(mouseScreenPos);		// Convert to client coordinates
									if( boardPictureBox.ClientRectangle.Contains( mouseClientPos ) )			// Check if inside the control
									{
										traceHandler.componentss[componentSelectorIndex].position = boardImage.boardCoordFromScreenCoordF( mouseClientPos );
									}
									redrawBoards();
									keyData = Keys.None;
								}
								break;
							case Keys.Escape:
								break;
						}
						break;
					case boardMouseModes.drawTrace:
						switch( keyData )
						{
							case Keys.Delete:
								drawTraceDeleteLast();
								break;
							case Keys.Escape:
								drawTraceAbort();
								keyData = Keys.None;
								break;
						}
						break;
					case boardMouseModes.insertVia:
						switch( keyData )
						{
							case Keys.Escape:
								break;
						}
						break;
					case boardMouseModes.insertThroughHole:
						switch( keyData )
						{
							case Keys.Escape:
								break;
						}
						break;
					case boardMouseModes.addComponent :
						int i = traceHandler.componentss.Count() - 1;
						float scaleX = traceHandler.componentss[i].Scale.X;
						float scaleY = traceHandler.componentss[i].Scale.Y;
						float tmpX = scaleX;
						float tmpY = scaleY;
						switch( keyData )
						{
							// Rotation of the component
							case Keys.R:
							case Keys.R | Keys.Shift:
							case Keys.R | Keys.Control:
								
								switch( keyData )
								{
									case Keys.R	:				traceHandler.componentss[i].Rotation += 90.0f; break;
									case Keys.R | Keys.Shift:	traceHandler.componentss[i].Rotation += 22.5f; break;
									case Keys.R | Keys.Control: traceHandler.componentss[i].Rotation +=  5.0f; break;
								}
								component.creationRotation = traceHandler.componentss[i].Rotation;
								Refresh();
								drawComponentMove();
								keyData = Keys.None;
								break;
							// Changing scale of the componenet
							case Keys.Right:	scaleX++; keyData = Keys.None; break;
							case Keys.Left:		scaleX--; keyData = Keys.None; break;
							case Keys.Up:		scaleY--; keyData = Keys.None; break;
							case Keys.Down:		scaleY++; keyData = Keys.None; break;

						}
						if( scaleX != tmpX || scaleY != tmpY )
						{
							if( scaleX < 1f ) scaleX = 1f;
							if( scaleY < 1f ) scaleY = 1f;
							traceHandler.componentss[i].Scale = new PointF( scaleX, scaleY );
							component.creationScale = new PointF( scaleX, scaleY );
							Refresh();
							drawComponentMove();
						}
						break;
				}
			}       // endif boardPictureBoxActive

			// Keys specific to the schematic display window
			if( circuitPictureBoxActive )
			{
				// Key actions irrespective of mode
				switch( keyData )
				{
					case Keys.Tab:         // although really a board action keeping it also in the schematic view as it is sometimes useful to peek at the other side of the board even when looking at the schematic
						buttonSwitchBoardLayerView_Click( new object(), new EventArgs() );
						keyData = Keys.None;
						break;

				}

				switch( circuitMouseMode  )
				{
					// Main mode
					case circuitMouseModes.mainMode:
						switch( keyData )
						{
							// Rotation and flipping of components
							case Keys.R:
							case Keys.X:
							case Keys.Y:
								if( componentSelectorIndex >= 0 && sectionSelectorIndex >= 0 )
								{
									component comp = traceHandler.componentss[componentSelectorIndex];
									switch( keyData )
									{
										case Keys.R:
											comp.rotate( sectionSelectorIndex );
											break;
										case Keys.X:
											comp.flipHorizontal( sectionSelectorIndex );
											break;
										case Keys.Y:
											comp.flipVertical( sectionSelectorIndex );
											break;
									}
									schem.drawSchematic( schemGraphics, traceHandler.componentss );
									Refresh();
									keyData = Keys.None;
								}
								break;
						}
						break;

					//Line drawing mode
					case circuitMouseModes.drawConnectionLine:
						switch( keyData  )
						{
							case Keys.Escape:
								drawingConnectionCancel( null, null );
								keyData = Keys.None;
								break;
							case Keys.Return:
								drawingConnectionEnd( null, null );
								keyData = Keys.None;
								break;
							case Keys.Delete:
								drawingConnectionDeletePoint( null, null );
								keyData = Keys.None;
								break;
							default:
								break;
						}
						break;
				}

			}   // endif circuitPictureBoxActive

			if( keyData == Keys.None )
				return true;
			else
				return base.ProcessCmdKey(ref msg, keyData);
        }

		// Main menu bar
		private void              newToolStripMenuItem_Click( object sender, EventArgs e )
		{
			createEmptyProject();
			

			mainFormReformat();
			redrawBoards();
		}
		private void             openToolStripMenuItem_Click( object sender, EventArgs e )
		{
			openProjectDialog.InitialDirectory = glob.projectFolder;
			openProjectDialog.FileName = glob.projectName+glob.projectFileSuffix;
			openProjectDialog.Filter = "Reeigne project (*.rgn)|*.rgn|All files (*.*)|*.*";
			openProjectDialog.CheckPathExists = true;
			openProjectDialog.CheckFileExists = true;
			openProjectDialog.ShowDialog();
		}
		private void             saveToolStripMenuItem_Click( object sender, EventArgs e )
		{
			saveProject();
		}
		private void           saveAsToolStripMenuItem_Click( object sender, EventArgs e )
		{
			//string fileName = glob.projectFolder + "\\" + glob.projectName+ glob.projectFileSuffix ;
			saveProjectDialog.InitialDirectory = glob.projectFolder;
			saveProjectDialog.FileName = glob.projectName + glob.projectFileSuffix;
			saveProjectDialog.CheckPathExists = true;
			saveProjectDialog.Filter = "Reeigne project (*.rgn)|*.rgn|All files (*.*)|*.*";
			saveProjectDialog.ShowDialog();
		}
		private void             exitToolStripMenuItem_Click( object sender, EventArgs e )
		{

		}
		private void symbolAssignmentToolStripMenuItem_Click( object sender, EventArgs e )
		{
			symbolSelectorForm sSForm = new symbolSelectorForm();
			sSForm.Show();
			Console.WriteLine( "Symbol form completed" );
		}
		private void      layerConfigToolStripMenuItem_Click( object sender, EventArgs e )
		{
			if( lCForm == null )
			{
				lCForm = new formLayerConfig();
				lCForm.Show();
			}
			else
			{
				if( lCForm.IsDisposed )
				{
					lCForm = new formLayerConfig();
					lCForm.Show();
				}
				else
				{
					lCForm.WindowState = FormWindowState.Normal;
					lCForm.BringToFront();
				}

			}
		}

		// Other callbacks
		private void openProjectDialog_FileOk( object sender, CancelEventArgs e )
		{
			string fullPath			= openProjectDialog.FileName;

			parseProjectpath( fullPath );

			//int lastSlashPosition	= fullPath.LastIndexOf( '\\' );    // finds position of last backslash
			//glob.projectFolder		= fullPath.Substring( 0, lastSlashPosition );
			//glob.projectName		= fullPath.Substring( lastSlashPosition + 1 );
			//int lastPeriodPosition	= glob.projectName.LastIndexOf( '.' );    // finds position of last backslash
			//glob.projectFileSuffix	= glob.projectName.Substring( lastPeriodPosition );
			//glob.projectName		= glob.projectName.Substring( 0,lastPeriodPosition );

			string fileName = glob.projectFolder + "\\" + glob.projectName+ glob.projectFileSuffix ;
			openProject( fileName );
		}
		private void saveProjectDialog_FileOk( object sender, CancelEventArgs e )
		{
			string fullPath         = saveProjectDialog.FileName;
			parseProjectpath( fullPath );

			//int lastSlashPosition	= fullPath.LastIndexOf( '\\' );    // finds position of last backslash
			//glob.projectFolder		= fullPath.Substring( 0, lastSlashPosition );
			//glob.projectName		= fullPath.Substring( lastSlashPosition + 1 );
			//int lastPeriodPosition	= glob.projectName.LastIndexOf( '.' );    // finds position of last backslash
			//glob.projectFileSuffix	= glob.projectName.Substring( lastPeriodPosition );
			//glob.projectName		= glob.projectName.Substring( 0,lastPeriodPosition );

			//string fileName = glob.projectFolder + "\\" + glob.projectName+ glob.projectFileSuffix ;
			saveProject( );
		}
	

		// public functions
		public int  numBoardImages()
        {   // this is mainly used just by the boardImages class during initialisation, for it to know how many instances of itself exist - there is probably a more elegant way of doing it
            return boardImages.Count;
        }
        public void setTextBoxes(string s1, string s2, string s3)
        {
            textBox1.Text = s1;
            textBox2.Text = s2;
            textBox3.Text = s3;
        }
		public void updateComponentInfoBox()
		{
			if( componentSelectorIndexZZ >= 0 )
			{
				textBoxDesigType.Text = traceHandler.componentss[componentSelectorIndex].desigType;
				textBoxDesigNum.Text = traceHandler.componentss[componentSelectorIndex].desigNum.ToString();
				textBoxDesigPart.Text = sectionSelectorIndex.ToString();
				if( traceHandler.componentss[componentSelectorIndex].symbol != null )
					textBoxComponentName.Text = traceHandler.componentss[componentSelectorIndex].symbol.name;
				else
					textBoxComponentName.Text = " --- ";
			}
			else
			{
				glob.mainForm.textBoxDesigType.Text = " - ";
				glob.mainForm.textBoxDesigNum.Text = " - ";
				glob.mainForm.textBoxDesigPart.Text = " - ";
				glob.mainForm.textBoxComponentName.Text = " --- ";
			}
		}
		// various internal functions
		private void mainFormReformat()
        {   // Reformats the controls and stuff in the main window to fit after resizing the window


			circuitPictureBox.Width = 50;       //KLUDGE to prevent window growing out of control
            boardPictureBox.Width   = 50;       //KLUDGE to prevent window growing out of control

            int formWidth           = this.ClientRectangle.Width;

			if( formWidth == 0 ) return;

            panelLeft.Width         = leftPanelWidth;
            panelMiddle.Width       = midPanelWidth;
            panelRight.Width        = rightPanelWidth;
            panelTop.Width          = formWidth;
            panelBottom.Width       = formWidth;

            panelLeft.Left          = 0;
            panelMiddle.Left        = (int)(formWidth * panelSplitRatio) - panelMiddle.Width / 2;
            panelRight.Left         = formWidth - panelRight.Width;
            panelTop.Left           = 0;
            panelBottom.Left        = 0;

            boardPictureBox.Left    = panelLeft.Right;
            boardPictureBox.Width   = panelMiddle.Left - boardPictureBox.Left;   //(formWidth - panelLeft.Width - midPanelWidth - rightPanelWidth) / 2;
            circuitPictureBox.Left  = panelMiddle.Right;
            circuitPictureBox.Width = panelRight.Left - circuitPictureBox.Left;


            int formHeight          = this.ClientRectangle.Height;

            panelTop.Top = 1;
            panelTop.Height         = topPanelHeight;
            panelBottom.Height      = bottomPanelHeight;
            panelLeft.Top           = panelTop.Bottom;
            panelMiddle.Top         = panelTop.Bottom;
            panelRight.Top          = panelTop.Bottom;

            boardPictureBox.Top     = panelTop.Bottom;
            circuitPictureBox.Top   = panelTop.Bottom;

            panelBottom.Top         = formHeight - panelBottom.Height;
            panelLeft.Height        = panelBottom.Top - panelTop.Bottom;
            panelMiddle.Height      = panelBottom.Top - panelTop.Bottom;
            panelRight.Height       = panelBottom.Top - panelTop.Bottom;
            boardPictureBox.Top     = panelTop.Bottom;
            boardPictureBox.Height  = panelBottom.Top - panelTop.Bottom;
            circuitPictureBox.Top   = panelTop.Bottom; ;
            circuitPictureBox.Height= panelBottom.Top - panelTop.Bottom;

			panelComponentInfo.Left = panelMiddle.Left + panelMiddle.Width / 2 - panelComponentInfo.Width / 2;
			
			boardBitMap =    new Bitmap( boardPictureBox.ClientRectangle.Width, boardPictureBox.ClientRectangle.Height );
			boardPictureBox.Image = boardBitMap;
			boardGraphics = Graphics.FromImage( boardPictureBox.Image );

			schemBitMap = new Bitmap( circuitPictureBox.ClientRectangle.Width, circuitPictureBox.ClientRectangle.Height );
			circuitPictureBox.Image = schemBitMap;
			schemGraphics = Graphics.FromImage( circuitPictureBox.Image );

			Refresh();

			redrawBoards();
			schem.drawSchematic( schemGraphics, traceHandler.componentss );
			Refresh();
		}

		private void createEmptyProject()
		{
			// close existing project, if any
			closeProject();

			// create the minimum required for a functioning blank project
			traceHandler.layers.Add( new layerInfo() { layer = 0, mirrored = false, name = "Front" } );
			traceHandler.layers.Add( new layerInfo() { layer = 1, mirrored = true, name = "Back" } );
		}

		private void openProject( string fileName)
		{
			closeProject();
			parseProjectpath( fileName );
			Console.WriteLine( ">>>Loading project" );
			StreamReader reader = new StreamReader( fileName );
			traceHandler.readLayers		( reader );
			traceHandler.readSegments	( reader );
			traceHandler.readVias		( reader );
			boardImage.readConfig		( reader, boardImages, this );
			component.readComponents	( reader, traceHandler.componentss );
			schem.readNetElements		( reader );
			reader.Close();
			Console.WriteLine( ">>>Ready" );
			traceHandler.findNetTopology();
			mainFormReformat();
			redrawBoards();
			updateFormTitle();
		}
		private void closeProject()
		{
			// Remove all existing data
			traceHandler = new traceHandler();
			while( boardImages.Count() > 0 )
			{
				boardImages[0].pictureHolder.Dispose();	   // need to dispose of these manually because they are not removed by the gargbage collector
				boardImages.RemoveAt( 0 );
			}
			schem = new schematic();
			schematic.netElements = new List<schematic.netElement>();
			glob.projectName = "newProject";
			updateFormTitle();
			
		}
		private void saveProject()
		{
			string fileName = glob.projectFolder + "\\" + glob.projectName + glob.projectFileSuffix;
			parseProjectpath( fileName );
			StreamWriter writer = new StreamWriter( fileName );
			traceHandler.writeLayers( writer );
			traceHandler.writeSegments( writer );
			traceHandler.writeVias( writer );
			boardImage.writeConfig( writer, boardImages );
			component.writeComponents( writer, traceHandler.componentss );
			schem.writeNetElements( writer );
			writer.Close();
			updateFormTitle();
		}
		private void saveCheckPoint()
		{
			string dateStamp = DateTime.Now.ToString("yyyy-MM-dd HHmmss");
			string fileName = glob.projectFolder + "\\" + glob.projectName + "-CHK" + dateStamp+ glob.projectFileSuffix;
			//parseProjectpath( fileName );	  // skip this because we don't want to change the actual filename to the name of the checkpoint file 
			StreamWriter writer = new StreamWriter( fileName );
			traceHandler.writeLayers( writer );
			traceHandler.writeSegments( writer );
			traceHandler.writeVias( writer );
			boardImage.writeConfig( writer, boardImages );
			component.writeComponents( writer, traceHandler.componentss );
			schem.writeNetElements( writer );
			writer.Close();
			updateFormTitle();
		}

		// generic helper functions
		private Point perpendicularOffset(Point startPoint, Point endPoint, int radius)
        {
            int dx = endPoint.X - startPoint.X;
            int dy = endPoint.Y - startPoint.Y;

            double length = Math.Sqrt(dx * dx + dy * dy);

            return new Point { X = (int)((dy * radius) / length), Y = -(int)((dx * radius) / length) };

            }
        private void  constrainLineWithin( ref Point startPoint, ref Point endPoint, Size size)
        {   // trims the ends of a line to fit within a rectangle
            // the rectangle is assumed to always originate at 0,0 since only the size is specified
            // can easily be modified to work for any rectangle by putting the edges of the rectabgle
            // in bx1,by1,bx2,by2 instead of putting zeros int bx1,bx2 and size in bx2,by2

            float lx1, ly1, lx2, ly2;  // co-ordinates of start and end of line
            float bx1, by1, bx2, by2;  // boundaries of window
            //float a, b, c, d;        // coefficients for the line equation (x-c)/a=(y-d/b)
            float resizeRatio;

            lx1 = startPoint.X;
            ly1 = startPoint.Y;
            lx2 = endPoint.X;
            ly2 = endPoint.Y;
            bx1 = 0;
            by1 = 0;
            bx2 = size.Width - 1;
            by2 = size.Height - 1;

            if (lx1 < bx1)    // startpoint is to the left of the border
            {
                resizeRatio = (lx2 - bx1) / (lx2 - lx1);
                lx1 = lx2 - (lx2 - lx1) * resizeRatio;
                ly1 = ly2 - (ly2 - ly1) * resizeRatio;
            }
            if (lx1 > bx2)    // startpoint is to the right of the border
            {
                resizeRatio = (lx2 - bx2) / (lx2 - lx1);
                lx1 = lx2 - (lx2 - lx1) * resizeRatio;
                ly1 = ly2 - (ly2 - ly1) * resizeRatio;
            }
            if (lx2 < bx1)    // endpoint is to the left of the border
            {
                resizeRatio = (lx1 - bx1) / (lx1 - lx2);
                lx2 = lx1 - (lx1 - lx2) * resizeRatio;
                ly2 = ly1 - (ly1 - ly2) * resizeRatio;
            }
            if (lx2 > bx2)    // endpoint is to the right of the border
            {
                resizeRatio = (lx1 - bx2) / (lx1 - lx2);
                lx2 = lx1 - (lx1 - lx2) * resizeRatio;
                ly2 = ly1 - (ly1 - ly2) * resizeRatio;
            }
            if (ly1 < by1)    // startpoint is above the border
            {
                resizeRatio = (ly2 - by1) / (ly2 - ly1);
                ly1 = ly2 - (ly2 - ly1) * resizeRatio;
                lx1 = lx2 - (lx2 - lx1) * resizeRatio;
            }
            if (ly1 > by2)    // startpoint is below the border
            {
                resizeRatio = (ly2 - by2) / (ly2 - ly1);
                ly1 = ly2 - (ly2 - ly1) * resizeRatio;
                lx1 = lx2 - (lx2 - lx1) * resizeRatio;
            }
            if (ly2 < by1)    // endpoint is above the border
            {
                resizeRatio = (ly1 - by1) / (ly1 - ly2);
                ly2 = ly1 - (ly1 - ly2) * resizeRatio;
                lx2 = lx1 - (lx1 - lx2) * resizeRatio;
            }
            if (ly2 > by2)    // endpoint is below the border
            {
                resizeRatio = (ly1 - by2) / (ly1 - ly2);
                ly2 = ly1 - (ly1 - ly2) * resizeRatio;
                lx2 = lx1 - (lx1 - lx2) * resizeRatio;
            }
            startPoint.X = (int)lx1;
            startPoint.Y = (int)ly1;
            endPoint.X = (int)lx2;
            endPoint.Y = (int)ly2;
        }
		private bool  menuItemHilite( ToolStripItemClickedEventArgs e, List<ToolStripItem> tSIList )
		{	// change the highlighting of an item specified in the event within the specified list of menu items. Returns true if the item is in the list or false if it isn't
			bool itemClicked = false;
			foreach( ToolStripItem cI in tSIList )
			{
				if( e.ClickedItem.Equals( cI ) ) itemClicked = true;
			}
			if( itemClicked )
			{
				foreach( ToolStripItem cI in tSIList )
				{
					cI.ForeColor = Color.Black;
					cI.BackColor = SystemColors.Control;
					if( e.ClickedItem.Equals( cI ) )
					{
						cI.BackColor = Color.Black;
						cI.ForeColor = Color.White;
						Console.WriteLine( ">{0}:{1}", cI.Name, e.ClickedItem.Equals( cI ) );
					}
				}
			}
			return itemClicked;
		}
		private void  removeMenuItem( ToolStripItemCollection itemList, string itemText )
		{	// Removes an item from the context menu
			ToolStripItem itemToRemove = null;
			foreach( ToolStripItem item in itemList )
			{
				if( item.Text == itemText ) itemToRemove = item;
			}
			if( itemToRemove != null ) itemList.Remove( itemToRemove );

		}
		private void updateFormTitle()
		{
			this.Text = glob.applicationName + "    " + glob.projectFolder + "\\" + glob.projectName;
		}
		public void parseProjectpath( string fullPath )
		{
			// After writing this I found out there already exists a class for handling directory paths,
			// its name being "Path".  For example string someString = Path.GetDirectoryName( someOtherString )
			int lastSlashPosition	= fullPath.LastIndexOf( '\\' );    // finds position of last backslash
			glob.projectFolder		= fullPath.Substring( 0, lastSlashPosition );
			glob.projectName		= fullPath.Substring( lastSlashPosition + 1 );
			int lastPeriodPosition	= glob.projectName.LastIndexOf( '.' );    // finds position of last backslash
			glob.projectFileSuffix	= glob.projectName.Substring( lastPeriodPosition );
			glob.projectName		= glob.projectName.Substring( 0,lastPeriodPosition );
		 }
		void writeRegistry()
		{
			RegistryKey key;
			key = Registry.CurrentUser.OpenSubKey( "SOFTWARE\\Reenigne" );
			if( key == null )
			{   // If there is no entry in the registry yet create the subkey and populate it
				key = Registry.CurrentUser.CreateSubKey( "SOFTWARE\\Reenigne" );
			}
			key.Close();
			key = Registry.CurrentUser.OpenSubKey( "SOFTWARE\\Reenigne", true );
			key.SetValue( "projectFolder",			glob.projectFolder			);
			key.SetValue( "projectName",			glob.projectName			);
			key.SetValue( "symbolLibraryFolder",	glob.symbolLibraryFolder	);
			key.Close();
		}
		void readRegistry()
		{
			RegistryKey key;
			key = Registry.CurrentUser.OpenSubKey( "SOFTWARE\\Reenigne" );
			if( key == null )
			{	// If there is no registry entry create one
				writeRegistry();
			}
			key = Registry.CurrentUser.OpenSubKey( "SOFTWARE\\Reenigne" );
			glob.projectFolder          = key.GetValue( "projectFolder"			).ToString();
			glob.projectName			= key.GetValue( "projectName"			).ToString();
			glob.symbolLibraryFolder	= key.GetValue( "symbolLibraryFolder"	).ToString();
			key.Close();
		}




		// some stuff for trying out language syntax and such - zmot is called when the 'exclamation' button is pressed
		private void zmot()
        {
            Console.WriteLine("TEST BUTTON PRESSED");
			//schematic.drawSchematic( schemGraphics, traceHandler.componentss );

			if( checkBoxBreak.Checked ) Debugger.Break();

			//sym.transform( 0, cW: true );
			//schematic.drawSchematic( schemGraphics, traceHandler.componentss /* quick: true*/ );
			//schematic.drawKSymbol( sym, schemGraphics, this );
			//Refresh();

			// Example of how to make queries on collections
			IEnumerable<schematic.netElement> nn = schematic.netElements.Where( i => i.netNum < 281 );

			// and how to iterate the query directly
			//foreach( schematic.netElement ne in schematic.netElements.Where(  i => i.netNum < 281 ) )
			//{
			//	Console.WriteLine( ne.netNum   );
			//}

			
			

			// public static List <netElement> netElements = new List<netElement>();
			//List<schematic.netElement> nn = new List<schematic.netElement>();
			//nn = schematic.netElements.Where( i => i.netNum < 281 );
		}
		public bool  debugBreak() { return checkBoxBreak.Checked; }

		private void boardPictureBox_Click( object sender, EventArgs e )
		{

		}





		//private void panelSelect_MouseLeave( object sender, EventArgs e )
		//{
		//	panelSelect.Visible = false;
		//}

		//private void radioButtonModeSelect_MouseEnter( object sender, EventArgs e )
		//{
		//	if( boardMouseMode == boardMouseModes.selectItem )
		//	{
		//		panelSelect.Visible = true;
		//	}
		//}
	}
}
